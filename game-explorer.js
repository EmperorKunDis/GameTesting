const puppeteer = require('puppeteer');
const fs = require('fs');

class GameExplorer {
    constructor() {
        this.visitedStates = new Map(); // Mapa nav≈°t√≠ven√Ωch stav≈Ø
        this.gameTree = {}; // Strom mo≈ænost√≠ hry
        this.currentPath = []; // Aktu√°ln√≠ cesta
        this.choiceHistory = new Map(); // Mapa proveden√Ωch voleb pro ka≈æd√Ω stav
        this.stateChoiceMap = new Map(); // Mapuje stav na proveden√© volby
        this.browser = null;
        this.page = null;
    }

    async init(gameUrl) {
        this.browser = await puppeteer.launch({ 
            headless: false, // Zobraz√≠ prohl√≠≈æeƒç pro sledov√°n√≠
            defaultViewport: { width: 1200, height: 800 }
        });
        this.page = await this.browser.newPage();
        await this.page.goto(gameUrl);
        await new Promise(resolve => setTimeout(resolve, 2000)); // Poƒçk√° na naƒçten√≠
    }

    // Z√≠sk√° text aktu√°ln√≠ sc√©ny a mo≈ænosti
    async getCurrentState() {
        try {
            const stateData = await this.page.evaluate(() => {
                // Funkce pro z√≠sk√°n√≠ unik√°tn√≠ho obsahu str√°nky
                function getUniquePageContent() {
                    // Z√≠sk√° v≈°echny textov√© uzly
                    const walker = document.createTreeWalker(
                        document.body,
                        NodeFilter.SHOW_TEXT,
                        null,
                        false
                    );
                    
                    let textContent = '';
                    let node;
                    while (node = walker.nextNode()) {
                        const text = node.textContent.trim();
                        if (text.length > 0) {
                            textContent += text + ' ';
                        }
                    }
                    return textContent.trim();
                }
                // Najde hlavn√≠ text hry (v√≠ce selektor≈Ø pro lep≈°√≠ kompatibilitu)
                const storySelectors = [
                    '.story-text', '.game-text', '.content', '.main-text', 
                    '[class*="story"]', '[class*="text"]', '[class*="content"]',
                    'main p', 'article p', '.container p', 'div p'
                ];
                
                let storyText = '';
                for (const selector of storySelectors) {
                    const element = document.querySelector(selector);
                    if (element && element.innerText.trim()) {
                        storyText = element.innerText.trim();
                        break;
                    }
                }
                
                if (!storyText) {
                    // Fallback: vezme prvn√≠ nepr√°zdn√Ω text element
                    const allP = document.querySelectorAll('p, div, span');
                    for (const el of allP) {
                        const text = el.innerText?.trim();
                        if (text && text.length > 20) {
                            storyText = text;
                            break;
                        }
                    }
                }
                
                // Pokus√≠ se z√≠skat v√≠ce textu ze str√°nky pro lep≈°√≠ identifikaci
                if (storyText.length < 100) {
                    const uniqueContent = getUniquePageContent();
                    if (uniqueContent.length > storyText.length) {
                        storyText = uniqueContent.substring(0, 800); // Vezme kompletn√≠ obsah
                    }
                }
                
                // Najde v≈°echny mo≈ænosti (roz≈°√≠≈ôen√© selektory)
                const options = [];
                const buttonSelectors = [
                    'button', '.option', '[role="button"]', 
                    'a[href*="#"]', 'a[onclick]', '.choice', '.button',
                    '[class*="option"]', '[class*="choice"]', '[class*="button"]',
                    'input[type="button"]', 'input[type="submit"]'
                ];
                
                const allButtons = [];
                buttonSelectors.forEach(selector => {
                    const elements = document.querySelectorAll(selector);
                    elements.forEach(el => allButtons.push(el));
                });
                
                // Odstran√≠ duplicity
                const uniqueButtons = [...new Set(allButtons)];
                
                uniqueButtons.forEach((btn, index) => {
                    const text = btn.innerText?.trim() || btn.value?.trim() || btn.getAttribute('aria-label')?.trim() || '';
                    if (text && 
                        !text.includes('ü§î Co udƒõl√°te?') && 
                        !text.includes('Menu') &&
                        !text.includes('Home') &&
                        text.length > 0 &&
                        text.length < 200) {
                        options.push({
                            index: index,
                            text: text,
                            element: btn.tagName + (btn.className ? '.' + btn.className.split(' ')[0] : ''),
                            visible: btn.offsetParent !== null
                        });
                    }
                });
    
                return {
                    storyText: storyText.substring(0, 600), // V√≠ce textu pro lep≈°√≠ rozli≈°en√≠ stav≈Ø
                    options: options.filter(opt => opt.visible),
                    url: window.location.href,
                    timestamp: Date.now(),
                    fullContent: getUniquePageContent() // Ulo≈æit cel√Ω obsah pro porovn√°n√≠
                };
            });
    
            console.log(`üîç Nalezen stav: "${stateData.storyText.substring(0, 80)}..."`);
            console.log(`‚ö° Mo≈ænosti (${stateData.options.length}): ${stateData.options.map(o => `"${o.text}"`).join(', ')}`);
            
            return stateData;
        } catch (error) {
            console.error('‚ùå Chyba p≈ôi z√≠sk√°v√°n√≠ stavu:', error);
            return {
                storyText: 'ERROR: Could not get state',
                options: [],
                url: this.page.url(),
                timestamp: Date.now()
            };
        }
    }

    // Vytvo≈ô√≠ hash pro identifikaci stavu
    createStateHash(stateData) {
        // Pou≈æije kompletn√≠ obsah str√°nky pro lep≈°√≠ rozli≈°en√≠ stav≈Ø
        const fullText = (stateData.fullContent || stateData.storyText).replace(/\s+/g, ' ').trim().toLowerCase();
        
        // Vytvo≈ô√≠ detailnƒõj≈°√≠ hash vƒçetnƒõ specifick√Ωch ƒç√°st√≠ obsahu
        const optionsText = stateData.options
            .map(o => o.text.replace(/\s+/g, ' ').trim().toLowerCase())
            .join('|||'); // Ne≈ôad√≠ mo≈ænosti, zachov√°v√° po≈ôad√≠
        
        // P≈ôid√° cestu jako dal≈°√≠ rozli≈°ovaƒç
        const pathContext = this.currentPath.join('>>');
        
        // Vytvo≈ô√≠ hash z kombinace cesty, textu a mo≈ænost√≠
        const hashInput = `PATH:${pathContext}***FULLTEXT:${fullText}***OPTIONS:${optionsText}`;
        const hash = Buffer.from(hashInput).toString('base64').substring(0, 32);
        
        console.log(`üîë Hash pro stav: ${hash}`);
        console.log(`üìÑ Cesta: ${pathContext}`);
        console.log(`üìÑ Text uk√°zka: ${fullText.substring(0, 50)}...`);
        return hash;
    }

    // Klikne na mo≈ænost
    async clickOption(optionIndex) {
        try {
            const success = await this.page.evaluate((index) => {
                const buttonSelectors = [
                    'button', '.option', '[role="button"]', 
                    'a[href*="#"]', 'a[onclick]', '.choice', '.button',
                    '[class*="option"]', '[class*="choice"]', '[class*="button"]',
                    'input[type="button"]', 'input[type="submit"]'
                ];
                
                const allButtons = [];
                buttonSelectors.forEach(selector => {
                    const elements = document.querySelectorAll(selector);
                    elements.forEach(el => allButtons.push(el));
                });
                
                const uniqueButtons = [...new Set(allButtons)].filter(btn => {
                    const text = btn.innerText?.trim() || btn.value?.trim() || '';
                    return text.length > 0 && btn.offsetParent !== null;
                });
                
                if (uniqueButtons[index]) {
                    const button = uniqueButtons[index];
                    console.log('Clicking button:', button.innerText || button.value);
                    
                    // Zkus√≠ r≈Øzn√© zp≈Øsoby kliknut√≠
                    if (button.click) {
                        button.click();
                        return true;
                    } else if (button.onclick) {
                        button.onclick();
                        return true;
                    } else if (button.href) {
                        window.location.href = button.href;
                        return true;
                    }
                }
                return false;
            }, optionIndex);
            
            if (!success) {
                console.warn(`‚ö†Ô∏è Nepoda≈ôilo se kliknout na mo≈ænost ${optionIndex}`);
                return false;
            }
            
            // Poƒçk√° na zmƒõnu str√°nky nebo obsahu
            await Promise.race([
                this.page.waitForNavigation({ waitUntil: 'networkidle0', timeout: 5000 }).catch(() => null),
                new Promise(resolve => setTimeout(resolve, 2000))
            ]);
            
            return true;
        } catch (error) {
            console.error(`‚ùå Chyba p≈ôi klik√°n√≠ na mo≈ænost ${optionIndex}:`, error.message);
            return false;
        }
    }

    // Hlavn√≠ pr≈Øzkumn√° metoda
    async explore() {
        console.log('üéÆ Zaƒç√≠n√°m pr≈Øzkum hry...');
        await this.exploreRecursively();
        await this.saveResults();
    }

    async exploreRecursively(depth = 0) {
        if (depth > 25) { // Zv√Ω≈°en√° maxim√°ln√≠ hloubka
            console.log('‚ö†Ô∏è Dosa≈æena maxim√°ln√≠ hloubka pr≈Øzkumu');
            return;
        }

        console.log(`\nüìç === HLOUBKA ${depth} ===`);
        console.log(`üõ§Ô∏è Aktu√°ln√≠ cesta: ${this.currentPath.join(' ‚Üí ')}`);
        
        const currentState = await this.getCurrentState();
        if (!currentState || !currentState.storyText) {
            console.error('‚ùå Nelze z√≠skat stav str√°nky');
            return;
        }
        
        const stateHash = this.createStateHash(currentState);
        
        console.log(`üìñ P≈ô√≠bƒõh: ${currentState.storyText.substring(0, 100)}...`);
        console.log(`üéØ Mo≈ænosti (${currentState.options.length}): ${currentState.options.map(o => `"${o.text}"`).join(', ')}`);

        // Zkontroluje, jestli u≈æ byl tento stav nav≈°t√≠ven
        if (this.visitedStates.has(stateHash)) {
            const previousVisit = this.visitedStates.get(stateHash);
            console.log('‚úÖ Stav ji≈æ nav≈°t√≠ven, vrac√≠m se...');
            console.log(`üìä Celkem nav≈°t√≠veno: ${this.visitedStates.size} stav≈Ø`);
            console.log(`üïê P≈ôedchoz√≠ n√°v≈°tƒõva: ${previousVisit.path.join(' ‚Üí ')}`);
            return;
        }

        // Oznaƒç√≠ stav jako nav≈°t√≠ven√Ω
        this.visitedStates.set(stateHash, {
            ...currentState,
            path: [...this.currentPath],
            timestamp: new Date().toISOString()
        });

        // Ulo≈æ√≠ do stromu hry
        this.gameTree[stateHash] = {
            text: currentState.storyText,
            options: currentState.options.map(o => ({ 
                text: o.text, 
                explored: false,
                chosen: false,
                chosenAt: null
            })),
            children: {}
        };

        // Inicializuje mapu voleb pro tento stav
        if (!this.stateChoiceMap.has(stateHash)) {
            this.stateChoiceMap.set(stateHash, new Set());
        }

        // Kontrola, zda m√° stav nƒõjak√© mo≈ænosti
        if (currentState.options.length === 0) {
            console.log('üèÅ Koncov√Ω stav - ≈æ√°dn√© dal≈°√≠ mo≈ænosti');
            return;
        }

        // Projde v≈°echny mo≈ænosti
        for (let i = 0; i < currentState.options.length; i++) {
            const option = currentState.options[i];
            const choiceKey = `${stateHash}:${option.text}`;
            const wasChosen = this.choiceHistory.has(choiceKey);
            
            console.log(`üîÑ Zkou≈°√≠m mo≈ænost ${i + 1}/${currentState.options.length}: "${option.text}"${wasChosen ? ' [JI≈Ω VYBR√ÅNO]' : ' [NOV√â]'}`);
            
            this.currentPath.push(option.text);
            
            // Ulo≈æ√≠ aktu√°ln√≠ URL pro n√°vrat
            const originalUrl = this.page.url();
            
            try {
                // Klikne na mo≈ænost
                const clickSuccess = await this.clickOption(option.index);
                
                if (clickSuccess) {
                    // Zaznaƒç√≠ volbu do historie
                    this.choiceHistory.set(choiceKey, {
                        stateHash: stateHash,
                        optionText: option.text,
                        timestamp: new Date().toISOString(),
                        path: [...this.currentPath]
                    });
                    
                    // Aktualizuje stateChoiceMap
                    this.stateChoiceMap.get(stateHash).add(option.text);
                    
                    // Oznaƒç√≠ mo≈ænost jako vybranou v game tree
                    if (this.gameTree[stateHash] && this.gameTree[stateHash].options[i]) {
                        this.gameTree[stateHash].options[i].chosen = true;
                        this.gameTree[stateHash].options[i].chosenAt = new Date().toISOString();
                    }
                    
                    // Rekurzivnƒõ prozkoum√° nov√Ω stav
                    await this.exploreRecursively(depth + 1);
                    
                    // Pokus√≠ se vr√°tit zpƒõt
                    try {
                        const currentUrl = this.page.url();
                        if (currentUrl !== originalUrl) {
                            console.log('üîô Vrac√≠m se zpƒõt...');
                            await this.page.goBack();
                            await new Promise(resolve => setTimeout(resolve, 1500));
                            
                            // Zkontroluje, zda se skuteƒçnƒõ vr√°til
                            const backUrl = this.page.url();
                            if (backUrl !== originalUrl) {
                                console.log('‚ö†Ô∏è N√°vrat se nezda≈ôil, obnovujem str√°nku...');
                                await this.page.goto(originalUrl);
                                await new Promise(resolve => setTimeout(resolve, 2000));
                            }
                        }
                    } catch (navError) {
                        console.warn('‚ö†Ô∏è Probl√©m s navigac√≠:', navError.message);
                        // Pokus o obnoven√≠ str√°nky
                        try {
                            await this.page.goto(originalUrl);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                        } catch (reloadError) {
                            console.error('‚ùå Nelze obnovit str√°nku:', reloadError.message);
                        }
                    }
                } else {
                    console.warn(`‚ö†Ô∏è P≈ôeskakuji mo≈ænost "${option.text}" - kliknut√≠ selhalo`);
                }
            } catch (error) {
                console.error(`‚ùå Chyba p≈ôi zpracov√°n√≠ mo≈ænosti "${option.text}":`, error.message);
            }
            
            this.currentPath.pop();
            
            // Oznaƒç√≠ mo≈ænost jako prozkoumanou
            if (this.gameTree[stateHash] && this.gameTree[stateHash].options[i]) {
                this.gameTree[stateHash].options[i].explored = true;
            }
        }
    }

    // Ulo≈æ√≠ v√Ωsledky do souboru
    async saveResults() {
        const results = {
            totalStates: this.visitedStates.size,
            totalChoices: this.choiceHistory.size,
            gameTree: this.gameTree,
            visitedStates: Object.fromEntries(this.visitedStates),
            choiceHistory: Object.fromEntries(this.choiceHistory),
            stateChoiceMap: Object.fromEntries(
                Array.from(this.stateChoiceMap.entries()).map(([key, value]) => [key, Array.from(value)])
            ),
            timestamp: new Date().toISOString()
        };

        // Ulo≈æ√≠ jako JSON
        fs.writeFileSync('game_exploration_results.json', JSON.stringify(results, null, 2));
        
        // Vytvo≈ô√≠ ƒçiteln√Ω report
        let report = `üìä REPORT PR≈ÆZKUMU HRY\n`;
        report += `========================\n\n`;
        report += `üî¢ Celkem stav≈Ø: ${this.visitedStates.size}\n`;
        report += `üéØ Celkem voleb: ${this.choiceHistory.size}\n`;
        report += `üìÖ Dokonƒçeno: ${new Date().toLocaleString('cs-CZ')}\n\n`;
        
        report += `üìù NAV≈†T√çVEN√â STAVY:\n`;
        report += `===================\n`;
        
        for (const [hash, state] of this.visitedStates) {
            const chosenOptions = this.stateChoiceMap.get(hash) || new Set();
            report += `\nüéØ Stav: ${hash}\n`;
            report += `üìñ Text: ${state.storyText.substring(0, 100)}...\n`;
            report += `üõ§Ô∏è Cesta: ${state.path.join(' ‚Üí ')}\n`;
            report += `‚ö° Mo≈ænosti: ${state.options.map(o => {
                const wasChosen = chosenOptions.has(o.text);
                return `${o.text}${wasChosen ? ' ‚úÖ' : ' ‚≠ï'}`;
            }).join(', ')}\n`;
            report += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
        }
        
        report += `\nüìã HISTORIE VOLEB:\n`;
        report += `==================\n`;
        
        for (const [choiceKey, choiceData] of this.choiceHistory) {
            report += `\nüéØ Volba: ${choiceData.optionText}\n`;
            report += `üìç Stav: ${choiceData.stateHash}\n`;
            report += `üïê ƒåas: ${new Date(choiceData.timestamp).toLocaleString('cs-CZ')}\n`;
            report += `üõ§Ô∏è Cesta: ${choiceData.path.join(' ‚Üí ')}\n`;
            report += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
        }

        fs.writeFileSync('game_exploration_report.txt', report);
        
        console.log('üíæ V√Ωsledky ulo≈æeny do:');
        console.log('   üìÑ game_exploration_results.json');
        console.log('   üìÑ game_exploration_report.txt');
    }

    async close() {
        if (this.browser) {
            await this.browser.close();
        }
    }
}

// Pou≈æit√≠:
async function main() {
    const explorer = new GameExplorer();
    
    try {
        // Nahraƒète URL adresou va≈°√≠ hry
        await explorer.init('https://vase-hra.cz'); 
        
        await explorer.explore();
        
        console.log('üéâ Pr≈Øzkum dokonƒçen!');
        
    } catch (error) {
        console.error('‚ùå Chyba:', error);
    } finally {
        await explorer.close();
    }
}

// Spust√≠ pr≈Øzkum
// main();

module.exports = GameExplorer;